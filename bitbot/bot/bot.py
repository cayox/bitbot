import json
import logging
import time
import datetime as dt
from bitbot import services, strategy
import pandas as pd


class Bot:
    """
    A trading bot that executes a certain strategy

    Attributes:
        config (dict[str, any]): the loaded configuration
        next_action (services.OrderDirection): the next action; wether to sell or to buy
        history (pandas.DataFrame): a history of all transactions the bot has made

    Args:
        config (str or dict[str,any]): the configuration that the bot should use

    """
    def __init__(self, config: str or dict[str, any]):
        if isinstance(config, str):
            with open(config, encoding="utf8") as f:
                self.config = json.load(f)
        else:
            self.config = config

        # initialize service class from imports
        self.service : services.ServiceInterface = getattr(services, self.config["service"])()
        # initialze strategy class from imports
        self.strat : strategy.TradingStrategyInterface = getattr(strategy, self.config["strat"]["name"])(self.service, self.config["strat"], self.config["market"])

        self.history = pd.DataFrame()
    
    def run(self):
        """
        Method to start the Bot. Runs in an endless loop and alternates between buying and selling, based on the signal 
        generated by the strategy used. Always executes market orders. Sleeps for the ``update_interval`` Seconds at the end of 
        every loop iteration.

        Saves buying time, buying proceeds and order direction in an attribute called ``history``
        """
        while True:
            last_price = self.service.get_market_ticker(self.config["market"])["lastTradeRate"]
            logging.info(f"## {self.config['market']} ## Last Price: {last_price}")
            available_balance = self.service.get_available_balance(self.config["market"].split("-")[0])

            candles = self.service.get_candles(self.config["market"], 
                                               self.service.determine_candle_interval(dt.timedelta(minutes=self.config["lookback"])))
            candles = candles.rename(columns={"startsAt": "time"})
            candles["rsi"] = self.strat.calc_rsi(candles)

            candles = self.strat.calc_macd(candles)
            signal = self.strat.generate_signal(candles)
            
            if signal != services.OrderDirection.NONE:
                order = services.Order(self.config["market"], signal, services.OrderType.MARKET, 
                                           services.TimeInForce.IMMEDIATE_OR_CANCEL, 
                                           self.config["quantity"] if self.config["quantity"] <= available_balance else available_balance)

                try:
                    res = self.service.place_order(order)
                except Exception as e:
                    logging.error(f"{e}")
                    # TODO : remove raise
                    raise e
                    return
                
                if res["status"] != "CLOSED":
                    logging.warning(f'Could not place Order: Status: {res["status"]}')
                else:
                    logging.info(f'Placed Order: {res}')

                    self.history = self.history.append({"time": dt.datetime.utcnow(), "value": res["proceeds"], "direction": self.next_action}, ignore_index=True)
                    self.next_action = services.OrderDirection.SELL if self.next_action == services.OrderDirection.BUY else services.OrderDirection.BUY

            time.sleep(self.config["update_interval"])
